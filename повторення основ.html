<script>
  // 1. Hoisting (Підняття)

  //   Завдання 1
  //   Що виведе цей код? Чому?
  //   console.log(a);
  //   var a = 10;
  //   console.log(a);

  //   Відповідь:
  //   undefined
  //   10

  //   Пояснення:
  //   Змінні, оголошені через var, піднімаються (hoisting), але їх значення не ініціалізується до фактичного присвоєння.
  //   Тому перший console.log(a) виведе undefined.

  //   Завдання 2
  //   Що станеться при виконанні коду?

  // console.log(b);
  // let b = 5;

  // Відповідь:
  // ReferenceError: Cannot access 'b' before initialization
  // Пояснення:
  // Змінні, оголошені через let або const, також піднімаються, але залишаються в "Temporal Dead Zone" (TDZ) до моменту ініціалізації, тому доступ до них до цього моменту викличе помилку.

  //   2. Блокова область видимості (Scope)

  //   Завдання 3. Спроба змінити значення константи
  // Код:

  // const c = 30;
  // c = 40;
  // console.log(c);

  // Пояснення та відповідь:
  // const оголошує константу, значення якої неможливо змінити після ініціалізації.

  // Спроба присвоєння нового значення призведе до TypeError.

  //   Завдання 4. Блокова область видимості для let
  //   Код:

  //   let x = 5;
  //   {
  //     let x = 10;
  //     console.log("Всередині блоку:", x);
  //   }
  //   console.log("Ззовні блоку:", x);

  //   Пояснення та відповідь:
  //   Змінні, оголошені через let, мають блочну область видимості.

  //   Усередині блоку змінна x має значення 10.
  //   Ззовні блоку використовується оригінальна x зі значенням 5.

  //   Завдання 5. Відсутність блочної області видимості для var
  // Код:

  // var y = 5;
  // {
  //   var y = 10;
  //   console.log("Всередині блоку:", y);
  // }
  // console.log("Ззовні блоку:", y);

  // Пояснення та відповідь:
  // Оголошення через var має функціональну (або глобальну) область видимості, тому блок не створює нову змінну.

  // Як всередині блоку, так і ззовні y матиме значення 10.

  // Відповідь:
  // Всередині блоку: 10
  // Ззовні блоку: 10

  //   Завдання 6. Повторне оголошення змінних
  // Частина А. Використання var:

  // var z = 1;
  // var z = 2;
  // console.log(z);

  // Пояснення та відповідь:
  // var дозволяє повторне оголошення однієї і тієї ж змінної в одному обсязі видимості.

  // Код виведе 2.
  // Частина Б. Використання let:

  // let w = 1;
  // let w = 2;
  // console.log(w);

  // Пояснення та відповідь:
  // let не дозволяє повторне оголошення змінної з однаковим іменем в одній області видимості.

  // Код викличе SyntaxError, тому що друга декларація w недопустима.

  // Завдання 7. Змінні в циклах: var проти let
  // Частина А. Використання var у циклі:

  // for (var i = 0; i < 3; i++) {
  //   setTimeout(() => console.log("var i:", i), 100);
  // }
  // Пояснення:
  // Змінна i, оголошена через var, є функціональною. Після завершення циклу її значення стає 3, тому всі callback-функції setTimeout виведуть 3.
  // Відповідь:

  // var i: 3
  // var i: 3
  // var i: 3

  // Частина Б. Використання let у циклі:

  // for (let j = 0; j < 3; j++) {
  //   setTimeout(() => console.log("let j:", j), 100);
  // }
  // Пояснення:
  // let оголошує змінну з блочною областю видимості, тому кожна ітерація циклу має свою копію j.
  // Відповідь:

  // let j: 0
  // let j: 1
  // let j: 2

  //TYPEOF
  // Завдання 1. Основи typeof
  // Що виведе код?

  // console.log(typeof 42);
  // console.log(typeof "Hello");
  // console.log(typeof true);
  // console.log(typeof undefined);
  // console.log(typeof null);
  // Пояснення та відповідь:

  // typeof 42 → "number" (число)
  // typeof "Hello" → "string" (рядок)
  // typeof true → "boolean" (булеве значення)
  // typeof undefined → "undefined"
  // typeof null → "object" (історична помилка в JS)

  // Відповідь:
  // "number"
  // "string"
  // "boolean"
  // "undefined"
  // "object"

  //   Завдання 2. Typeof для об'єктів
  // Що виведе код?

  // console.log(typeof { name: "Nick" });
  // console.log(typeof [1, 2, 3]);
  // console.log(typeof function() {});
  // console.log(typeof new Date());
  // Пояснення та відповідь:

  // { name: "Nick" } → "object" (звичайний об'єкт)
  // [1, 2, 3] → "object" (масив – це об'єкт)
  // function() {} → "function" (функції – окремий тип, хоча вони теж є об'єктами)
  // new Date() → "object" (дата – це об'єкт)

  // Відповідь:
  // "object"
  // "object"
  // "function"
  // "object"

  //   Завдання 3. Typeof для спеціальних значень
  // Що виведе код?

  // console.log(typeof NaN);
  // console.log(typeof Infinity);
  // console.log(typeof Symbol("id"));
  // console.log(typeof BigInt(12345678901234567890));

  // Пояснення та відповідь:
  // NaN → "number" (не число, але все ще тип number)
  // Infinity → "number" (нескінченне значення теж вважається number)
  // Symbol("id") → "symbol" (спеціальний унікальний тип)
  // BigInt(12345678901234567890) → "bigint" (велике число)

  // Відповідь:
  // "number"
  // "number"
  // "symbol"
  // "bigint"

  //   Завдання 4. Typeof для змінних, що не були оголошені
  // Що виведе код?

  // console.log(typeof someVariable);

  // Пояснення:
  // Якщо змінна не була оголошена, typeof не викликає помилку, а повертає "undefined".

  // Відповідь:
  // "undefined"

  //   Завдання 6. Перевірка типу значення перед використанням
  // Який буде результат виконання цього коду?

  // function safeDivide(a, b) {
  //   if (typeof a !== "number" || typeof b !== "number") {
  //     return "Помилка: обидва аргументи мають бути числами!";
  //   }
  //   return a / b;
  // }

  // console.log(safeDivide(10, 2));
  // console.log(safeDivide(10, "2"));

  // Пояснення та відповідь:
  // Перше виклик safeDivide(10, 2) поверне 5.
  // Другий виклик safeDivide(10, "2") поверне "Помилка: обидва аргументи мають бути числами!", тому що "2" – рядок.

  // Відповідь:
  // 5
  // "Помилка: обидва аргументи мають бути числами!"
</script>
