<!-- How to iterate over a callback n times in JavaScript? -->
<!-- Як виконати повторний виклик n разів у JavaScript? -->

<!-- Given a callback function, we have to iterate over a callback n times. The callback is a function that is passed as an argument. To iterate over the callback function, we have to run the callback function n time. -->
<!-- Маючи функцію зворотного виклику, ми повинні повторити зворотний виклик n разів. Зворотний виклик — це функція, яка передається як аргумент. Щоб виконати ітерацію функції зворотного виклику, ми повинні запустити функцію зворотного виклику n раз. -->

<!-- Використання рекурсії для повторення функції зворотного виклику n разів.
По-перше, створіть фактор функції зворотного виклику, яка приймає n як аргумент.
Факторна функція генерує шаблон довжиною n.
Створіть тестову функцію, яка приймає функцію зворотного виклику та n.
Тестова функція перевіряє, чи значення n дорівнює 0, а ні.
Якщо n дорівнює 0, повертається функція перевірки завершення, інакше викликається функція зворотного виклику, яка друкує шаблон. -->

<!-- Вихід
01 02 03 04
01 02 03
01 02
01 -->
<!-- <script>
  // приклад
  // function pow(x, n) {
  //   if (n == 1) {
  //     return x;
  //   } else {
  //     return x * pow(x, n - 1);
  //   }
  // }

  function factor(n) {
    if (n <= 0) {
      return;
    }

    // string to store patterns
    let str = '';
    // loop for generate pattern
    for (let i = 1; i <= n; i++) {
      str += `0${i} `;
    }
    // printing patterns
    console.log(str);

    // recursion call with decrement by 1
    factor(n - 1);
  }

  function test(n, callback) {
    if (n == 0) {
      console.log('please provide value n greater than 0');
      return;
    }

    let k = n;
    //calling callback function
    callback(k);
  }

  test(5, factor);
</script> -->
<!-- 
Using a loop statement to iterate over the callback. 
First, we create a callback function factor which generates a factorial of numbers.
Create a test function with argument n and a callback function.
Check the value of n if it is invalid terminate if not continue.
Create for loop with range n.
On each loop call the callback function which prints the factorial of each number. -->

<!-- Використання оператора циклу для повторення зворотного виклику. 
Спочатку ми створюємо фактор функції зворотного виклику, яка генерує факторіал чисел.
Створіть тестову функцію з аргументом n і функцією зворотного виклику.
Перевірте значення n, якщо воно недійсне, завершіть, якщо не продовжуйте.
Створіть цикл for із діапазоном n.
У кожному циклі викликається функція зворотного виклику, яка друкує факториал кожного числа. -->

<!-- !n = n*(n-1)*...*1;  -->
<!-- <script>
  function factor(number) {
    let result = 1;
    for (let i = 1; i <= number; i++) {
      result *= i;
    }

    console.log(`факторіал ${number} є
${result}}`);
  }

  function test(n, callback) {
    if (n <= 0) {
      console.log('invalid number');
      return;
    }

    for (let i = n; i > 0; i--) {
      callback(i);
    }
  }

  // initialising test variable
  let t_umber = 5;
  // main function calling
  test(t_umber, factor);
</script> -->

<!-- Вихід
факторіал 5 є
120
факторіал 4 є
24
факторіал 3 є
6
факторіал 2 є
2
факторіал 1 є
1 -->
<!-- <script>
  f();
  function f() {}

  let a = 2 + 3;
  let f = function () {};

  let f = () => {};

  function func(...args) {
    args.map();
  }

  func(1, 2, 3, 4, 5, 6, 7);
</script> -->

<!-- Завдання 1:
Створи функцію calculate, яка приймає 3 аргументи: два числа і операцію у вигляді рядка ("+", "-", "*", "/"). Поверни результат обчислення. Якщо операція невідома — поверни "Невідома операція". -->
<!-- <script>
  function calculate(num1, num2, action) {
    switch (action) {
      case '+':
        return a + b;
      case '-':
        return a - b;
      case '*':
        return a * b;
      case '/':
        return num2 !== 0 ? num1 / num2 : 'На 0 ділити не можна';
      default:
        return 'Невідома операція';
    }
  }

  calculate(1, 1, '/');
</script> -->

<!-- Завдання 2:
Напиши функцію createCounter, яка повертає іншу функцію. Кожен виклик цієї внутрішньої функції має повертати наступне число (1, 2, 3...). -->
<!-- <script>
  function createCounter() {
    let count = 0;

    return () => {
      return ++count;
    };
  }

  let func = createCounter();
  console.log(func()); //1
  console.log(func()); //2
  console.log(func()); //3
</script> -->
